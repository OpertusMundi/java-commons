package eu.opertusmundi.common.model.asset;

import java.time.ZonedDateTime;
import java.util.List;
import java.util.UUID;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonInclude.Include;

import eu.opertusmundi.common.model.Message;
import eu.opertusmundi.common.model.RecordLockDto;
import eu.opertusmundi.common.model.account.ProviderDto;
import eu.opertusmundi.common.model.catalogue.client.CatalogueItemCommandDto;
import eu.opertusmundi.common.model.catalogue.client.EnumAssetType;
import eu.opertusmundi.common.model.catalogue.client.EnumSpatialDataServiceType;
import io.swagger.v3.oas.annotations.Hidden;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class AssetDraftDto {

    @JsonIgnore
    private int id;

    @JsonIgnore
    private String processInstance;

    @Schema(description=
          "Draft unique identifier. "
        + "Also the key for the catalogue draft record. "
        + "If the draft is submitted and a workflow instance "
        + "is initialized, it is used as the business key"
    )
    private UUID key;

    @Schema(description = "Asset title")
    private String title;

    @Schema(description = "Asset version")
    private String version;

    @Schema(description = "Asset type")
    private EnumAssetType type;

    @Schema(description = "Asset service type. Applicable only when asset type is `SERVICE`")
    private EnumSpatialDataServiceType serviceType;

    @Schema(description = "Draft data", implementation = CatalogueItemCommandDto.class)
    private CatalogueItemCommandDto command;

    @Schema(description = "Catalogue draft id. Always equal to key property")
    private UUID assetDraft;

    @Schema(description = "Published asset id. The value is generated by the PID service")
    private String assetPublished;

    @Schema(description = "Draft status")
    private EnumProviderAssetDraftStatus status;

    @Schema(description = "Rejection reason if the draft has been rejected by a HelpDesk user")
    private String helpdeskRejectionReason;

    @Schema(description = "Rejection reason if the draft has been rejected by the provider")
    private String providerRejectionReason;

    @Schema(description = "`true` if the data profiling task should be executed during the asset publish workflow")
    private boolean dataProfilingEnabled;

    @Schema(description = "`True` if the geometry has been set by automated metadata")
    private boolean computedGeometry;

    @Schema(description = "Creation date in ISO format")
    private ZonedDateTime createdOn;

    @Schema(description = "Date of lat update in ISO format")
    private ZonedDateTime modifiedOn;

    @Schema(description = "Owner account key")
    private UUID owner;

    @Schema(description = "Draft parent asset PID")
    private String parentId;

    @Schema(description = "Publisher details")
    private ProviderDto publisher;

    @Schema(description = "Lock details. If a lock exists, the record type is always `DRAFT`")
    @JsonInclude(Include.NON_NULL)
    private RecordLockDto lock;

    @Hidden
    @Schema(description = "Workflow error details")
    @JsonInclude(Include.NON_EMPTY)
    private String workflowErrorDetails;

    @Hidden
    @ArraySchema(
        arraySchema = @Schema(
            description = "Workflow error messages"
        ),
        minItems = 0,
        uniqueItems = true
    )
    @JsonInclude(Include.NON_EMPTY)
    private List<Message> workflowErrorMessages;

    @Schema(description = "Helpdesk error message")
    @JsonInclude(Include.NON_EMPTY)
    private String helpdeskErrorMessage;

    public ResourceDto getResourceByKey(String key) {
        return this.getCommand().getResources().stream()
            .filter(r -> r.getId().equals(key))
            .findFirst()
            .orElse(null);
    }

}
