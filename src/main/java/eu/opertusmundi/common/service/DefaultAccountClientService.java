package eu.opertusmundi.common.service;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.Optional;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import eu.opertusmundi.common.domain.AccountClientEntity;
import eu.opertusmundi.common.model.PageResultDto;
import eu.opertusmundi.common.model.ServiceException;
import eu.opertusmundi.common.model.account.AccountClientCommandDto;
import eu.opertusmundi.common.model.account.AccountClientDto;
import eu.opertusmundi.common.model.account.AccountMessageCode;
import eu.opertusmundi.common.model.account.EnumAccountClientStatus;
import eu.opertusmundi.common.model.keycloak.server.ClientDto;
import eu.opertusmundi.common.model.keycloak.server.CredentialDto;
import eu.opertusmundi.common.repository.AccountClientRepository;

@Service
public class DefaultAccountClientService implements AccountClientService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultAccountClientService.class);

    static final String DEFAULT_BASE_URL = "http://localhost:8080/";

    private final URL defaultBaseUrl;

    @Value("${opertusmundi.account-client-service.default-access-token-lifespan:10800}")
    private int defaultAccessTokenLifespanSeconds;

    @Value("${opertusmundi.account-client-service.keycloak.realm:Services}")
    private String realm;

    private final AccountClientRepository accountClientRepository;

    private final KeycloakAdminService keycloakAdminService;

    @Autowired
    public DefaultAccountClientService(
        AccountClientRepository accountClientRepository,
        Optional<KeycloakAdminService> keycloakAdminService) throws MalformedURLException
    {
        this.accountClientRepository = accountClientRepository;
        this.keycloakAdminService = keycloakAdminService.orElse(null);
        this.defaultBaseUrl = new URL(DEFAULT_BASE_URL);
    }

    @Override
    public PageResultDto<AccountClientDto> findAll(UUID accountKey, EnumAccountClientStatus status, Pageable pageable) {
        final Page<AccountClientDto> page = (switch (status) {
            case ACTIVE -> this.accountClientRepository.findAllActiveByAccountKey(accountKey, pageable);
            case REVOKED -> this.accountClientRepository.findAllRevokedByAccountKey(accountKey, pageable);
            default -> this.accountClientRepository.findAllByAccountKey(accountKey, pageable);
        }).map(AccountClientEntity::toDto);

        return PageResultDto.of(pageable.getPageNumber(), pageable.getPageSize(), page.getContent(), page.getTotalElements());
    }

    @Override
    public AccountClientDto create(AccountClientCommandDto command) throws ServiceException {
        try {
            // Check alias uniqueness
            if (this.accountClientRepository.findOneByAccountIdAndAlias(command.getAccountId(), command.getAlias()).isPresent()) {
                throw new ServiceException(AccountMessageCode.ACCOUNT_CLIENT_NOT_UNIQUE_ALIAS, "Client with the same alias already exists");
            }

            // Create Keycloak client and retrieve the client secret
            final UUID clientId = UUID.randomUUID();
            String clientSecret = "";

            if (keycloakAdminService != null) {
                final ClientDto client = ClientDto.createWithDefaults(clientId.toString(), defaultBaseUrl);
                client.setEnabled(true);
                client.setName(command.getAlias());
                client.setPublicClient(false);
                client.setServiceAccountsEnabled(true);
                client.setDirectAccessGrantsEnabled(false);
                client.setAccessTokenLifespan(defaultAccessTokenLifespanSeconds);
                // Note: clientUuid (generated by Keycloak when a client is created) is different for our clientId!
                final UUID clientUuid = keycloakAdminService.createClient(realm, client);
                clientSecret = keycloakAdminService.getClientSecret(realm, clientUuid)
                    .map(CredentialDto::getValue).get();
            }

            // Create local account client
            final AccountClientDto result =
                this.accountClientRepository.create(command.getAccountId(), command.getAlias(), clientId);
            result.setSecret(clientSecret);

            return result;
        } catch (final ServiceException ex) {
            throw ex;
        } catch (final Exception ex) {
            final String message = String.format(
                "Failed to create account client. [accountId=%d, clientAlias=%s]",
                command.getAccountId(), command.getAlias()
            );

            logger.error(message, ex);

            throw new ServiceException(AccountMessageCode.ACCOUNT_CLIENT_ERROR, "Failed to create new account client");
        }
    }

    @Override
    @Transactional
    public void revoke(Integer accountId, UUID clientId) throws ServiceException {
        try {
            final AccountClientEntity e = this.accountClientRepository.findOneByAccountIdAndClientId(accountId, clientId).orElse(null);
            if (e == null) {
                throw new ServiceException(AccountMessageCode.ACCOUNT_CLIENT_NOT_FOUND, "Client was not found");
            }

            if (e.getRevokedOn() == null) {
                // Revoke local client
                this.accountClientRepository.revoke(accountId, clientId);

                // Delete Keycloak client
                if (keycloakAdminService != null) {
                    final UUID clientUuid = keycloakAdminService.getClientById(realm, clientId.toString())
                        .map(ClientDto::getId)
                        .orElse(null);
                    if (clientUuid != null) {
                        keycloakAdminService.deleteClient(realm, clientUuid);
                    }
                }
            }
        } catch (final ServiceException ex) {
            throw ex;
        } catch (final Exception ex) {
            final String message = String.format("Failed to revoke account client. [accountId=%d, clientId=%s]",
                accountId, clientId);

            logger.error(message,  ex);

            throw new ServiceException(AccountMessageCode.ACCOUNT_CLIENT_ERROR, "Failed to revoke existing account client");
        }
    }
}
